#!/bin/bash
set -e
# Inspired by https://gist.github.com/akorn/644855ddaa8065f564be
# Usage:
#   rsync_parallel.sh --parallel=N --hosts=START_INDEX [--total_bw=MBPS] [rsync args...]
#
# Options:
#   --parallel=N         Use N parallel processes for transfer.
#   --hosts=START_INDEX  Starting index for hosts. Will use hosts START_INDEX through START_INDEX+N-1.
#   --total_bw=MBPS      Total bandwidth in Mbps to distribute across transfers (optional).
#
# Notes:
#   * Requires GNU Parallel
#   * Supports both remote-to-local and local-to-remote transfers
#   * Assumes SSH keys are already configured for all hosts
#   * Does an itemize-changes first, then chunks the resulting file list and launches N parallel
#     rsyncs to transfer a chunk each.
#   * be a little careful with the options you pass through to rsync. Normal ones will work, you
#     might want to test weird options upfront.
#   * Make sure your SSH config has the sequential hosts defined properly.
#
# Define colours for STDERR text
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
NC='\033[0m' # No Color

if ! command -v parallel &> /dev/null
then
  echo -e "${RED}parallel could not be found${NC}"
  exit 1
fi

# Default parallel processes
if [[ "$1" == --parallel=* ]]; then
  PARALLEL_RSYNC="${1##*=}"
  shift
else
  echo -e "${RED}ERROR: --parallel=N parameter is required${NC}"
  exit 1
fi

# Process hosts starting index
if [[ "$1" == --hosts=* ]]; then
  HOST_START_INDEX="${1##*=}"
  shift
else
  echo -e "${RED}ERROR: --hosts=START_INDEX parameter is required${NC}"
  exit 1
fi

# Process total bandwidth if provided
TOTAL_BW_MBPS=""
BANDWIDTH_PER_TRANSFER=""

if [[ "$1" == --total_bw=* ]]; then
  TOTAL_BW_MBPS="${1##*=}"
  # Calculate bandwidth limit per transfer
  # Convert Mbps to KB/s: Mbps รท 8 ร 1024 = KB/s
  TOTAL_BANDWIDTH=$((TOTAL_BW_MBPS * 1024 / 8))  # Convert Mbps to KB/s
  BANDWIDTH_PER_TRANSFER=$((TOTAL_BANDWIDTH / PARALLEL_RSYNC))
  shift
fi

echo -e "${GREEN}INFO: Using up to ${PARALLEL_RSYNC} processes for transfer ...${NC}"
echo -e "${GREEN}INFO: Using hosts ${HOST_START_INDEX} through $((HOST_START_INDEX + PARALLEL_RSYNC - 1)) ...${NC}"

if [ -n "$TOTAL_BW_MBPS" ]; then
  echo -e "${GREEN}INFO: Total bandwidth: ${TOTAL_BW_MBPS} Mbps (${TOTAL_BANDWIDTH} KB/s)${NC}"
  echo -e "${GREEN}INFO: Bandwidth per transfer: ${BANDWIDTH_PER_TRANSFER} KB/s${NC}"
else
  echo -e "${GREEN}INFO: Bandwidth limiting disabled${NC}"
fi

# Extract source and destination arguments
SOURCE_ARG=""
DEST_ARG=""
RSYNC_OPTS=()

# Store all remaining arguments
REMAINING_ARGS=("$@")

# First, identify remote paths (containing a colon)
REMOTE_PATHS=()
for arg in "${REMAINING_ARGS[@]}"; do
  if [[ "$arg" =~ : ]]; then
    REMOTE_PATHS+=("$arg")
  fi
done

# Check that there is exactly one remote path
if [[ ${#REMOTE_PATHS[@]} -ne 1 ]]; then
  echo -e "${RED}ERROR: Exactly one remote path must be specified (found ${#REMOTE_PATHS[@]})${NC}"
  exit 1
fi

# The source and destination should be the last two arguments
for ((i=0; i<${#REMAINING_ARGS[@]}; i++)); do
  if [[ $i -lt $(( ${#REMAINING_ARGS[@]} - 2 )) ]]; then
    RSYNC_OPTS+=("${REMAINING_ARGS[$i]}")
  elif [[ $i -eq $(( ${#REMAINING_ARGS[@]} - 2 )) ]]; then
    SOURCE_ARG="${REMAINING_ARGS[$i]}"
  else
    DEST_ARG="${REMAINING_ARGS[$i]}"
  fi
done

# Check if source or destination is the remote path
IS_UPLOAD=false
if [[ "$SOURCE_ARG" =~ : ]]; then
  # Remote to local (download)
  REMOTE_ARG="$SOURCE_ARG"
  LOCAL_ARG="$DEST_ARG"
  IS_UPLOAD=false
  echo -e "${GREEN}INFO: Detected DOWNLOAD operation (remote to local)${NC}"
elif [[ "$DEST_ARG" =~ : ]]; then
  # Local to remote (upload)
  REMOTE_ARG="$DEST_ARG"
  LOCAL_ARG="$SOURCE_ARG"
  IS_UPLOAD=true
  echo -e "${GREEN}INFO: Detected UPLOAD operation (local to remote)${NC}"
else
  echo -e "${RED}ERROR: Could not identify remote path. Format should be [user@]host:/path${NC}"
  exit 1
fi

# Parse the remote argument
if [[ "$REMOTE_ARG" =~ ^([^@]+@)?([^:]+):(.+)$ ]]; then
  if [[ -n "${BASH_REMATCH[1]}" ]]; then
    REMOTE_USER="${BASH_REMATCH[1]%@}"
  else
    REMOTE_USER="" # No user specified
  fi
  REMOTE_HOST="${BASH_REMATCH[2]}"
  REMOTE_PATH="${BASH_REMATCH[3]}"
else
  echo -e "${RED}ERROR: Could not parse remote path. Format should be [user@]host:/path${NC}"
  exit 1
fi

TMPDIR=$(mktemp -d)
trap 'rm -rf "${TMPDIR}"' EXIT
echo -e "${GREEN}INFO: Determining file list for transfer ...${NC}"

# For both upload and download, we need to get the file list
if [ "$IS_UPLOAD" = true ]; then
  # For upload, source is local
  rsync "${RSYNC_OPTS[@]}" --out-format="%l %n" --no-v --dry-run "$SOURCE_ARG" "$DEST_ARG" 2> /dev/null \
    | grep -v "sending incremental file list" \
    | sort --numeric-sort --reverse \
    > "${TMPDIR}/files.all"
else
  # For download, source is remote
  rsync "${RSYNC_OPTS[@]}" --out-format="%l %n" --no-v --dry-run "$SOURCE_ARG" "$DEST_ARG" 2> /dev/null \
    | grep -v "sending incremental file list" \
    | sort --numeric-sort --reverse \
    > "${TMPDIR}/files.all"
fi

# check for nothing-to-do
TOTAL_FILES=$(wc -l < "${TMPDIR}/files.all")
TOTAL_SIZE=$(awk '{ts+=$1}END{printf "%.0f", ts}' < "${TMPDIR}/files.all")
echo -e "${GREEN}INFO: ${TOTAL_FILES} ($(( TOTAL_SIZE/1024**2 )) MB) files to transfer.${NC}"

if [ "${TOTAL_FILES}" -eq "0" ]; then
  echo -e "${ORANGE}WARN: Nothing to transfer :)${NC}"
  exit 0
fi

# Remove the directories from files.all to avoid duplicate transfers
grep -v '/$' "${TMPDIR}/files.all" > "${TMPDIR}/files.filtered"
mv "${TMPDIR}/files.filtered" "${TMPDIR}/files.all"

echo -e "${GREEN}INFO: Proceeding with file distribution...${NC}"

function array_min {
  ARR=("$@")
  # Default index for min value
  min_i=0
  # Default min value
  min_v=${ARR[$min_i]}
  for i in "${!ARR[@]}"; do
    v="${ARR[$i]}"
    (( v < min_v )) && min_v=${v} && min_i=${i}
  done
  MIN_I="${min_i}"
}

echo -e "${GREEN}INFO: Distributing files among chunks ...${NC}"
# declare chunk-size array
for ((I = 0 ; I < PARALLEL_RSYNC ; I++ )); do
  CHUNKS["${I}"]=0
done

# add each file to the emptiest chunk, so they're as balanced by size as possible
PROGRESS=0
SECONDS=0
while read -r FSIZE FPATH; do
  PROGRESS=$((PROGRESS+1))
  array_min "${CHUNKS[@]}"
  CHUNKS[MIN_I]=$(( CHUNKS[MIN_I] + FSIZE ))
  echo "${FPATH}" >> "${TMPDIR}/chunk.${MIN_I}"
  if ! ((PROGRESS % 25000)); then
    >&2 echo -e "${GREEN}INFO: ${PROGRESS} of ${TOTAL_FILES} (${SECONDS}s)${NC}"
  fi
done < "${TMPDIR}/files.all"

# Reverse the list of files in every other chunk for better transfer efficiency
for ((I = 1 ; I < PARALLEL_RSYNC ; I+=2 )); do
  # If the list of files to transfer is small, we may not have any files to work with
  if [ ! -f "${TMPDIR}/chunk.${I}" ]; then
    continue
  fi

  tac "${TMPDIR}/chunk.${I}" > "${TMPDIR}/chunk.${I}.r" && mv "${TMPDIR}/chunk.${I}.r" "${TMPDIR}/chunk.${I}"
done
echo -e "${GREEN}DONE (${SECONDS}s)${NC}"

echo -e "${GREEN}INFO: Starting transfers ...${NC}"

# Create commands for parallel
COMMANDS=()
CHUNK_FILES=($(find "${TMPDIR}" -type f -name "chunk.*"))
for ((i=0; i<${#CHUNK_FILES[@]}; i++)); do
  CHUNK_FILE="${CHUNK_FILES[$i]}"
  CURRENT_HOST_NUM=$((HOST_START_INDEX + i))

  # Build the command with --files-from and --no-dirs
  CMD="rsync --files-from=${CHUNK_FILE} --no-dirs"

  # Add bandwidth limit if specified
  if [ -n "$BANDWIDTH_PER_TRANSFER" ]; then
    CMD="${CMD} --bwlimit=${BANDWIDTH_PER_TRANSFER}"
  fi

  # Add the remaining options
  CMD="${CMD} ${RSYNC_OPTS[*]}"

  if [ "$IS_UPLOAD" = true ]; then
    # For upload, we're connecting to different destination hosts
    if [[ -n "$REMOTE_USER" ]]; then
      DEST="${REMOTE_USER}@${CURRENT_HOST_NUM}:${REMOTE_PATH}"
    else
      DEST="${CURRENT_HOST_NUM}:${REMOTE_PATH}"
    fi
    CMD="${CMD} ${LOCAL_ARG} ${DEST}"
  else
    # For download, we're connecting to different source hosts
    if [[ -n "$REMOTE_USER" ]]; then
      SRC="${REMOTE_USER}@${CURRENT_HOST_NUM}:${REMOTE_PATH}"
    else
      SRC="${CURRENT_HOST_NUM}:${REMOTE_PATH}"
    fi
    CMD="${CMD} ${SRC} ${LOCAL_ARG}"
  fi

  COMMANDS+=("$CMD")
done

# Use parallel to run all commands
echo -e "${GREEN}INFO: Running ${#COMMANDS[@]} rsync jobs in parallel...${NC}"
printf '%s\n' "${COMMANDS[@]}" | parallel -j "${PARALLEL_RSYNC}" --verbose --progress
echo -e "${GREEN}DONE (${SECONDS}s)${NC}"